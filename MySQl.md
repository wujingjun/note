# 为什么使用索引

MySQL 官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。

影响数据库效率的原因千千万万，使用索引是为了解决哪方面的数据库的瓶颈？

## 第一点

MySQL 数据库存储数据最终是以文件的形式存储到硬盘的。一般来说，我们在程序中使用的时候肯定要把磁盘文件的数据读到内存中。那么就这个”读“的过程是什么样子的呢？磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为**寻道时间**、**旋转延迟**、**传输时间**三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘的寻道时间一般在5ms以下；旋转延迟就是1/120/2 = 4.17ms（旋转延迟等于磁盘转动半圈时间）；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，弹药知道一台 500 - MIPS 的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令（如果以CPU的指令执行效率来比较的化），数据库动辄千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图。

![](D:\note\MySQl.assets\1326851-20190711193112961-231739917-1677209926718.png)

所以，问题的症结在于磁盘IO是非常高昂的操作。



## 解决方案



### 方式一

计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的是数据，而是把相邻的数据也都读取到内存缓冲区，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每次IO读取的数据我们称之为一页（page）。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO（一次IO的数据包括当前要读取的磁盘地址的数据+与之相邻的数据），这个理论对于索引的数据设计非常有帮助。



### 方式二

**每次查找数据时把磁盘IO次数控制在一个很小的数量级**

很明显：第一种解决方案是系统已经提供好的，要想实现第二种解决方案就需要一种稳定的数据结构能够满足几乎每次查询数据进行磁盘的IO次数是很少的。这个条件可以解释为：每次查询数据进行IO次数都很少，说明这个数据结构不能像红黑树一样树的高度不可控，于是一个高度可控的多路搜索树就产生了，这就是B+树。

在这里要阐述清楚一件事情：那么B+树的每一个节点（以磁盘的角度可以称作：磁盘块；参照下图）究竟存的是什么？以一张表的id列为例，也就是主键列是如果是索引的话，那么这张表的每一个id都会以B+树的每一个节点存储到B+树上，如果数据过多，一个节点就会存储多个id。



**B+树**

![](D:\note\MySQl.assets\1326851-20190711193309056-1214246401-1677211057791.png)



如上图，是一颗B+树，关于B+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35（如果以id为例的话，就代表一个节点（磁盘块）存放了两个id），包含指针P1,P2,P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，**只存储指引搜索方向的数据项（也就是说可以理解为17、35的一个缩影），17、35并不真实存在于非叶子节点中。**



**那么B+树的查找数据的过程又是怎样的呢？**

​	如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存（并不是将所有的磁盘块（节点）一次性都加入到内存中），此时发生一次IO（磁盘加载到内存的这个过程称为一次IO），在内存中使用**二分查找**确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计3次IO。真实的情况是，3层的B+树可以表示上百万的数据（以ID作为索引的话就是几百万个ID也就是几百万条数据），如果上百万的数据查找只需要三次IO（每一个磁盘块中存储多个ID）,性能提高将是巨大的，如果没有索引，每个磁盘块都要发生一次IO（**即使磁盘块里面可以装多个数据项的缩影，但是由于单个磁盘块的大小是4k或者8k，这是由于操作系统限制的，所以单个磁盘块中不可能存储太多数据，所以磁盘块的数据依然很多**）。



**B+ 树的性质**

1. 通过上面的查找数据的过程，我们知道IO次数取决于B+树的高度 h ,假设当前数据表的数据为N，每个磁盘块的数据项的数量是m,则有 h = log(m+1) N,当数据量 N 一定的情况下，m越大，h越小；而 m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小（**虽然数据项中存储的是索引字段的缩影，但是缩影的占字节数还是和真实的数据有关系的**），比如 int 占4字节，要比bigint8 字节少一半。这也是为什么 B+ 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1（**一个数据项占用一个磁盘块**）时将会**退化成线性表**。
2. 当B+树的数据项是复合的数据结构，比如（name,age,gender）的时候，B+树是按照**从左到右的顺序来建立搜索树的**，比如当（张三，20，F）这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name相同再依次比较age和gender，最后得到检索的数据；但当（20,F）这样的没有name的数据来的时候，B+树就不知道下一步该查哪个节点，因为佳安里搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当（张三，F）这样的数据来检索时，B+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了，这个是非常重要的性质，即索引的**最左匹配特性**。





# 索引及其优缺点



## 优点

1. 类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本，这也是创建素银最主要的原因。
2. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
3. 在实现数据的参考完整性方面，可以加速表与表的连接。换句话说，对于有依赖关系的子表和附表联合查询，可以提高查询速度。
4. 在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。



## 缺点

增加索引也有许多不利的方面，主要表现在如下几个方面

1. 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。
2. 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。
3. 虽然索引大大提高查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。





# 页的理解



## 页的概述

+ 为了避免一条一条读取磁盘数据，InnoDB采取页的方式，作为磁盘和内存之间交互的基本单位。
+ 一个页的大小一般是16KB
+ InnoDB为了不同的目的而设计了多种不同类型的页。比如：存放表空间头部信息的页、存放undo日志信息的页等等。
+ 存放表中数据记录的页，称为索引页或者数据页





## InnoDB存储引擎中数据页的结构示意图

![](D:\note\MySQl.assets\c528bfff34464ea880917c088729f3a4-1677461911074.png)





## 记录在数据页中的存储方式

1. 行格式或者记录格式的理解

   + 我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存放形式也被称为**行格式**或者**记录格式**

2. 记录在页中的存储示意图

   ![](D:\note\MySQl.assets\d1b5e0fc223e491e9fc57a83bcecfac7-1677462238085.png)

3. 记录在页中的存储整个流程

   上如示意图可知：

   + 在一开始形成页的时候，没有UserRecords部分
   + 当插入一条记录时，就会从Free Space中申请一个记录大小的空间，并将这个空间划分到User Records部分。
   + 当Free Space部分的空间全部都被User Records部分替代掉后，则这个页使用完了，如果再有新的记录插入，则需要去申请新的页了。





## 记录头信息的理解

1. COMPACT行格式示意图

   ![](D:\note\MySQl.assets\471ca1a68c354d1b830b695dcfcb99ce-1677462554069.png)

2. 记录头信息的说明

   1. deleted_flag：删除标记。0：未删除 1：已删除

      1. 为什么被删除的记录还在页中？或者说，依然在磁盘上？

         ```
         这些被删除得记录之所以没有从磁盘上删除，是因为如果移除了，还需要再磁盘攀上重新排列剩余得记录，这会带来一定的性能消耗，所以只是打了一个删除的标记就可以避免重排。然后所有被删除掉的记录会组成一个垃圾链表，记录在这个链表中占用的空间被称为可重用空间。之后若是由新的记录插入到表中，它们就可以覆盖掉被删除的这些记录占用的存储空间了。
         ```

   2. min_rec_flag：B+树中每层非叶子节点中的最小的目录项记录，都会添加该标记。

   3. n_owned：一个页面被分若干组后，“带头大哥”用于保存组中所有的记录条数。

   4. heap_no：表示当前记录在页面堆中的相对位置。

      1. 什么叫页面堆？heap_no作用是什么?

         ```
         页面堆：我们向表中插入的记录都会放到User Record部分，这些记录一条条的连续排列着，InnoDB将此连续排列的结构称为堆。
         heap_no：为了方便管理，他们把一条记录在堆中的相对位置称之为heap_no。
         heap_no作用：堆中记录的heap_no值在分配之后就不会发生改动了，即使删除堆中的某条记录，这条被删除记录的heap_no值页仍然保持不变。
         ```

      2. 为什么用户记录的heap_no从2开始？

         ```
         因为创建页时，每个页会自动添加两条记录，且都没有主键值：
         一条代表页面中最小的记录（即：比任何用户记录都小）--Infimum记录，heap_no = 0
         另一条代表页面中的最大记录（即：比任何用户记录都大）--Supermum记录，heap_no = 1
         为了区分这两条默认记录和用户自己插入的记录，将这两条记录放到一个称为Infimum+Supermum的部分
         ```

   5. record_type：表示当前的记录类型。

      1. 0：普通记录
      2. 1：B+树非叶子节点的目录项记录
      3. 2：表示Infimum记录
      4. 3：表示Supermum记录

   6. next_record：表示下一条记录的相对位置。就是链表。这个属性非常重要。它表示从当前记录的真实数据到下一条记录的真实数据的距离。

      ![](D:\note\MySQl.assets\4ba1d61c8d2a4926b52477987af55806-1677464717553.png)

      + 为什么要指向【记录头信息】和【真实数据之间】的位置呢？而不是指向整条记录的开头位置

        ```
        因为这个位置刚刚好，向左读取就是记录头信息；向右读取就是真实数据。
        ```

      + next_record属性为正数和负数表示什么？

        ```
        该属性为正数--说明当前记录的下一条记录在它的后面
        该属性为负数--说明当前记录的下一条记录在它的前面
        比如：一条记录的next_record值为32，意味着从当前记录的真实数据的地址处向后找32
        字节便是下一条记录的真实数据。其中：「下一条记录」指的是按主键值由小到大的顺序
        排列的下一条记录。
        ```

      + **通过下图，可以看出记录是按照主键从小到大的顺序形成了一个单向链表。并且，记录被删除对next_record的影响，如下图所示：**

        ![](D:\note\MySQl.assets\eedadc59fc36488aa28c84b50890305f-1677465446519.png)

        ```
        deleted_flag变为了1，但是并没有从磁盘中删除。
        next_record变为了0，意味着没有下一条记录了。
        “tom”的next_record指向了“bob”。
        supremum记录的n_owned变为了4。
        如果再次执行插入操作 insert into tb_student values(3, 300, "jack");操作，
        InnoDB并不会因此申请新的存储空间，而是直接恢复原来被删除记录的存储空间。
        ```






# MySQL行记录格式

mysql的行记录格式是随着文件格式一起变化的，官网上说Antelope是早期的文件格式，它又包含了COMPACT和REDUNDANT行格式；

另外最新的文件格式是Barracuda,它包含COMPRESSED 和 DYNAMIC 行格式，与 COMPRESSED 和 DYNAMIC 行格式相关的功能包括压缩表、页外列的高校存储以及最多3072字节的索引键前缀。



## 思维导图

![](D:\note\MySQl.assets\e974699f12da4e9193b18a6690155255-1677551215849.png)



| 行格式     | 紧凑的存储特性 | 增强的可变长度列存储 | 大索引键前缀支持 | 压缩支持 | 支持的表空间类型                | 所需的文件格式        |
| ---------- | -------------- | -------------------- | ---------------- | -------- | ------------------------------- | --------------------- |
| REDUNDANT  | 否             | 否                   | 否               | 否       | system, file-per-table, general | Antelope or Barracuda |
| COMPACT    | 是             | 否                   | 否               | 否       | system, file-per-table, general | Antelope or Barracuda |
| DYNAMIC    | 是             | 是                   | 是               | 否       | system, file-per-table, general | Barracuda             |
| COMPRESSED | 是             | 是                   | 是               | 是       | file-per-table, general         | Barracuda             |





## REDUNDANT行格式



### 介绍

redundant提供了和老版本Mysql的兼容，并且是同时都被antelope和barracuda支持。使用REDUNDANT行格式的表将前768字节的可变长度列值（VARCHAR、VARBINARY以及BLOB和TEXT类型）存储在B树节点内的索引记录种，其余部分存储在溢出页上。大于或等于768字节的固定长度列被编码为可变长度列，可以在页外存储。

+ 例如，如果字符集的最大字节长度大于3，则 CHAR(255) 列可以超过768个字节，就像使用utf8mb4一样。这里稍微解释一下上面这句话，CHAR(255) 这个 255 说的是字符数，utf8的格式是三个字节是一个字符来表示中文，假设VARCHAR(10) ，所以10乘以3等于30。如果使用utf8mb4编码，是4个字节的话，就是10乘以4了，字节数就变成40了。要记住varchar这种括号后面保存的都是字符数而不是字节数。因此如果储存的列的值小于等于768字节的话，mysql就不会使用溢出页，数据直接保存在mysql的btree节点中，可以节省IO。这里简单提一下mysql的行溢出，如图：
  ![](D:\note\MySQl.assets\3ac40e8e0f342dc80504e8a1169b757d-1677554341002.png)

  图中所示，对于变长字段类型包括blob、text、varchar都是这样的存储方式，如果数据没有超过768字节，那么就直接存储在btree节点之中，如果是超过768的部分就会存储在溢出页里面。

+ 储存结构：![](D:\note\MySQl.assets\341a79a75ab915638903d6bf51fe27d9-1677554485849.png)

+ 头信息：

  ![](D:\note\MySQl.assets\8f7019d4f1a9d2ba358d5272035832b2-1677554576854.png)

+ 储存结构
  + 每个索引记录包含一个 6 字节的标头。标头用于将连续记录链接在一起，并用于行级锁定。
  + 聚集索引中的记录包含所有用户定义列的字段。此外，还有一个6字节的事务ID字段和一个7字节的滚动指针字段。
  + 如果没有为表定义主键，则每个聚集索引记录还包含一个6字节的行ID字段。
  + 每个二级索引记录包含为聚集索引键定义的所有不在二级索引中的主键列
  + 记录包含指向记录的每个字段的指针。如果一条记录的字段总长度小于128字节，则指针为1字节；否则，两个字节。指针数组称为记录目录。指针指向的区域是记录的数据部分。
  + 在内部，诸如CHAR(10)之类的固定长度字符列以固定长度格式存储。不会从VARCHAR列中截断尾随空格
  + 大于或等于768字节的固定长度列被编码为可变长度列，可以在页外存储。例如，如果字符集的最大字节长度大于3，则CHAR(255)列可以超过768个字节，就像使用utf8mb4一样。
  + SQL的NULL值在记录目录中保留一或两个字节。如果SQL的NULL值存储在可变长度列中，则在记录的数据部分保留零字节。对于定长列，该列的定长保留在记录的数据部分。为NULL值保留固定空间允许将列从NULL就地更新为非NULL值，而不会导致索引页碎片。





## COMPACT行记录

+ 介绍：与 REDUNDANT 行格式相比，COMPACT 行格式减少了大约 20% 的行存储空间，代价是增加了某些操作的 CPU 使用率。如果工作负载是典型的受缓存命中率和磁盘速度限制的工作负载，那么 COMPACT 格式可能会更快。如果工作负载受 CPU 速度限制，紧凑格式可能会更慢。简单来说compact对于IO密集型更有优势，对于计算密集型任务劣势更大。

+ 存储结构：

  ![](D:\note\MySQl.assets\98ee519a43e85b96fa41fd4be57ee157 (1)-1677556057476.png)

+ 头信息

  ![](D:\note\MySQl.assets\e4e4509dab3acf080486a73c9fcc2f18-1677556080372.png)

+ 储存特性：
  + 每个索引记录都包含一个5字节的标头，该标头前面可能有一个可变长度的标头。标头用于将连续记录链接在一起，并用于行级锁定。
  + 记录头的可变长度部分包含一个位向量，用于指示NULL列。如果索引中可以为NULL的列数为N，则位向量占用CEILING(N/8)字节。（例如，如果有9到16列可以为NULL，则位向量使用两个字节。）为NULL的列不占用此向量中的位以外的空间。标题的可变长度部分还包含可变长度列的长度。每个长度需要一个或两个字节，具体取决于列的最大长度。如果索引中的所有列都不是NULL并且具有固定长度，则记录头没有可变长度部分。
  + 对于每个非 NULL 可变长度字段，记录头包含一或两个字节的列长度。仅当部分列外部存储在溢出页中或最大长度超过 255 字节且实际长度超过 127 字节时才需要两个字节。对于外部存储的列，2字节长度表示内部存储部分的长度加上指向外部存储部分的 20 字节指针。内部部分是768字节，所以长度是768+20。 20字节的指针存储列的真实长度。
  + 记录头后面是非 NULL 列的数据内容。
  + 聚集索引中的记录包含所有用户定义列的字段。此外，还有一个6字节的事务ID字段和一个7字节的滚动指针字段。
  + 如果没有为表定义主键，则每个聚集索引记录还包含一个6字节的行ID字段。
  + 每个二级索引记录包含为聚集索引键定义的所有不在二级索引中的主键列。如果任何主键列是可变长度的，则每个二级索引的记录头都有一个可变长度部分来记录它们的长度，即使二级索引是在固定长度的列上定义的。
  + 在内部，对于非可变长度字符集，诸如 CHAR(10) 之类的固定长度字符列以固定长度格式存储。不会从VARCHAR列中截断尾随空格。在内部，对于 utf8mb3 和 utf8mb4 等可变长度字符集，InnoDB 尝试通过修剪尾随空格将 CHAR(N) 存储在 N 个字节中。如果 CHAR(N) 列值的字节长度超过 N 个字节，则将尾随空格修剪为列值字节长度的最小值。 CHAR(N) 列的最大长度为最大字符字节长度 × N。至少为 CHAR(N) 保留了 N 个字节。在许多情况下，保留最小空间 N 可以在不导致索引页碎片的情况下就地完成列更新。相比之下，CHAR(N) 列在使用 REDUNDANT 行格式时占用最大字符字节长度 × N。大于或等于 768 字节的固定长度列被编码为可变长度字段，可以在页外存储。例如，如果字符集的最大字节长度大于 3，则 CHAR(255) 列可以超过 768 个字节，就像使用 utf8mb4 一样。





## DYNAMIC

介绍：DYNAMIC 行格式提供与 COMPACT 行格式相同的存储特性，但为长可变长度列增加了增强的存储功能，并支持大索引键前缀，可以认为是compact的升级版本。Barracuda 文件格式支持 DYNAMIC 行格式（antelope不支持）。当使用 ROW_FORMAT=DYNAMIC 创建表时，InnoDB 可以完全离页存储长可变长度列值（对于 VARCHAR、VARBINARY 和 BLOB 和 TEXT 类型），聚集索引记录仅包含一个 20 字节的指向溢出页面。大于或等于 768 字节的固定长度字段被编码为可变长度字段。
（可以看到和redundant相比对于可变长字段dynamic是使用20字节指向溢出页，redundant是768储存在行，对于固定长度字段dynamic，redundant都是768）列是否存储在页外取决于页面大小和行的总大小。当一行太长时，选择最长的列进行页外存储，直到聚集索引记录适合 B 树页面。小于或等于 40 字节的 TEXT 和 BLOB 列存储在行中。
DYNAMIC 行格式在合适的情况下保持将整行存储在索引节点中的效率（与 COMPACT 和 REDUNDANT 格式一样），但 DYNAMIC 行格式避免了用大量数据字节填充 B 树节点的问题长列。 DYNAMIC 行格式基于这样的想法：如果长数据值的一部分存储在页外，通常将整个值存储在页外是最有效的。对于 DYNAMIC 格式，较短的列可能会保留在 B 树节点中，从而最大限度地减少给定行所需的溢出页数。
DYNAMIC 行格式支持最多 3072 个字节的索引键前缀。此功能由 innodb_large_prefix 变量控制，默认情况下启用。有关更多信息，请参阅 innodb_large_prefix 变量描述。
使用 DYNAMIC 行格式的表可以存储在系统表空间、每个表文件表空间和通用表空间中。要将 DYNAMIC 表存储在系统表空间中，请禁用 innodb_file_per_table 并使用常规的 CREATE TABLE 或 ALTER TABLE 语句，或者将 TABLESPACE [=] innodb_system 表选项与 CREATE TABLE 或 ALTER TABLE 一起使用。 innodb_file_per_table 和 innodb_file_format 变量不适用于一般表空间，也不适用于使用 TABLESPACE [=] innodb_system 表选项将 DYNAMIC 表存储在系统表空间中。






## COMPRESSED行格式

介绍：COMPRESSED 行格式提供与 DYNAMIC 行格式相同的存储特性和功能，但增加了对表和索引数据压缩的支持。Barracuda 文件格式支持 COMPRESSED 行格式。COMPRESSED 行格式使用与 DYNAMIC 行格式类似的页外存储内部详细信息，但表和索引数据的额外存储和性能考虑因素正在压缩并使用较小的页面大小。对于 COMPRESSED 行格式，KEY_BLOCK_SIZE 选项控制在聚集索引中存储多少列数据，以及在溢出页上放置多少列数据。
COMPRESSED 行格式支持最多 3072 个字节的索引键前缀。此功能由 innodb_large_prefix 变量控制，默认情况下启用。有关更多信息，请参阅 innodb_large_prefix 变量描述。
使用 COMPRESSED 行格式的表可以在 file-per-table 表空间或通用表空间中创建。系统表空间不支持 COMPRESSED 行格式。要将 COMPRESSED 表存储在 file-per-table 表空间中，必须启用 innodb_file_per_table 变量并且必须将 innodb_file_format 设置为 Barracuda。 innodb_file_per_table 和 innodb_file_format 变量不适用于一般表空间。通用表空间支持所有行格式，但需要注意的是，由于物理页大小不同，压缩表和未压缩表不能共存于同一个通用表空间中。

储存特性：和compact一样，是compact的变体
ps：COMPRESSED和compact不一样的地方主要在于存在其中的行数据会以zlib的格式压缩而节省空间。
