

# 消息队列

## MQ的相关概念



## 什么是MQ

MQ（message queue）,从字面意思上看，本质是个队列，FIFO先入先出，只不过队列存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ是一种非常常见的上下游"逻辑解耦+物理解耦"的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其它服务。



## 为什么要用MQ



### 流量消峰

举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单几十秒后才能收到下单成功的操作，但是比不能下单的体验要好



### 应用解耦

以电商应用为例，应用种有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出现故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间的调用的问题会少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。

![image-20230116101157419](D:\note\rabbitmq.assets\image-20230116101157419.png)





### 异步处理

有些服务间调用是异步的，例如A调用B，B需要花费很长的时间，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询Api查询。或者A提供一个callback api，B执行完之后调用api通知服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。这样A服务既不用循环调用B的查询Api，也不用提供callback api。同样B服务也不用做这些操作。A服务还能及时得到异步处理成功的消息。

![image-20230116111500791](D:\note\rabbitmq.assets\image-20230116111500791.png)





## RabbitMQ



### RabbitMQ的概念

RabbitMQ是一个消息中间件：它接受并转发消息。你可以把它当作一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑RabbitMQ是一个快递站，一个快递员帮你传递快件。RabbitMQ与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。



### 四大核心概念



#### 生产者

​	产生数据发送消息的程序是生产者



#### 交换机

​	交换机是RabbitMQ非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定



#### 队列

​	队列是RabbitMQ内部使用的一种数据结构，尽管消息流经 RabbitMQ和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式



#### 消费者

​	消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一个机器上。同一个应用程序既可以是生产者又是可以是消费者。





### 各个名词介绍

![image-20230117163924941](D:\note\rabbitmq.assets\image-20230117163924941.png)



**Broker**：接收和分发消息的应用，RabbitMQ Server就是Message Broker

**Virtual host：**出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似与网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange/queue等

**Connection：**publisher / consumer和broker之间的TCP连接

**Channel：**如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。 Channel作为轻量级的**connection极大减少了操作系统建立TCP connection的开销。**

